Introduction
------------

This package provides an effective version of infinitary term rewriting,
as described in the paper "Computing with Infinite Terms and Reductions"
by Jeroen Ketema and Jakob Grue Simonsen.

The Haskell code in this package has been tested with both version 6.12.3
of the Glasgow Haskell Compiler (GHC) and the September 2006 release of
Hugs 98. Both systems require certain extensions to be enabled on execution
of the code:

* GHC requires "-XTypeSynonymInstances"  and "-XMultiParamTypeClasses" options

* Hugs requires the "-X" option

To obtain GHC, it is best to install the Haskell Platform:

  http://hackage.haskell.org/platform/

The source code of Hugs 98 can be obtained from:

  http://www.haskell.org/hugs/

Usage
-----

To experiment with the code, it is best to load either CompressionExamples.hs
(for the compression theorem), ConfluenceExamples.hs (for the confluence
theorem), or ChurchRosserExamples.hs (for the Church-Rosser theorem) in the
interpreter supplied with either GHC (ghci) or Hugs 98 (hugs). Then, input
the examples as described in the comments of the respective source files.

Structure
---------

The code has been split in several files whose contents should be mostly
obvious from the file names, or otherwise from the initial comments in
each of the files.

Besides employing a recursive data type instead of natural numbers, the
code deviates in two ways from the presentation in the paper:

* A special type is defined, in OmegaReductions.hs, to represent reductions
  of length at most omega. This type is employed in the context of the Strip
  Lemma, confluence, and the Church-Rosser theorem and implicitly assumes
  the univalent system of notation for omega from SystemsOfNotation.hs. The
  introduction of the special type is mere programming convenience, making
  the code cleaner and omitting the otherwise obligatory compression that
  needs to be performed in the confluence and Church-Rosser theorems.

* The needed steps function for both transfinite reductions and reductions up
  to length omega combine the computation of the prefix-closed subset of
  positions of the final term of a reduction and the actual needed step
  computation. Again, this is a mere programming convenience, leading to
  slightly cleaner code.

Correspondence with the Paper
-----------------------------

The correspondence between the Turing machines defined in the Theorems, Lemmas,
etc of the paper and the functions as present in the code is as follows:

Lemma 1       : substitute     in Substitutions.hs
Proposition 2 : subterm        in PositionsAndSubterms.hs
Lemma 3       : rewrite_step   in RulesAndSystems.hs
Theorem 5     : compression    in Compression.hs
Proposition 6 : origins_across in RulesAndSystems.hs (across a single step)
Proposition 7 : needed_steps   in OmegaReductions.hs
                                      and TransfiniteReductions.hs
Theorem 10    : confluence     in Confluence.hs
Lemma 11      : implicit in StripLemma.hs
Lemma 12      : strip_lemma    in StripLemma.hs
Theorem 15    : church_rosser  in ChurchRosser.hs
Lemma 16      : interleave     in ChurchRosser.hs

(End of README)

